<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Benchmarking a pi calculation for fun | James Hughes</title>
<meta name=keywords content="nodejs,golang,java,python,c,programming,pi,algorithms"><meta name=description content="Dotnet Core, Golang, Node, C, Java, Python.
This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js.  As is typical when things like these arise, our team&rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - &ldquo;Do you think cypress would be faster than selenium?&rdquo;"><meta name=author content="James D Hughes"><link rel=canonical href=https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jimdhughes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jimdhughes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jimdhughes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jimdhughes.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jimdhughes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/"><meta property="og:site_name" content="James Hughes"><meta property="og:title" content="Benchmarking a pi calculation for fun"><meta property="og:description" content="Dotnet Core, Golang, Node, C, Java, Python.
This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js. As is typical when things like these arise, our team’s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - “Do you think cypress would be faster than selenium?”"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-05-22T09:51:39+00:00"><meta property="article:modified_time" content="2019-05-22T09:51:39+00:00"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Java"><meta property="article:tag" content="Python"><meta property="article:tag" content="C"><meta property="article:tag" content="Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Benchmarking a pi calculation for fun"><meta name=twitter:description content="Dotnet Core, Golang, Node, C, Java, Python.
This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js.  As is typical when things like these arise, our team&rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - &ldquo;Do you think cypress would be faster than selenium?&rdquo;"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Benchmarking a pi calculation for fun","item":"https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Benchmarking a pi calculation for fun","name":"Benchmarking a pi calculation for fun","description":"Dotnet Core, Golang, Node, C, Java, Python.\nThis is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js. As is typical when things like these arise, our team\u0026rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - \u0026ldquo;Do you think cypress would be faster than selenium?\u0026rdquo;\n","keywords":["nodejs","golang","java","python","c","programming","pi","algorithms"],"articleBody":"Dotnet Core, Golang, Node, C, Java, Python.\nThis is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js. As is typical when things like these arise, our team’s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - “Do you think cypress would be faster than selenium?”\nAn article that came up in slack is here: https://www.skylinetechnologies.com/Blog/Skyline-Blog/March_2018/pi-day-compare-dotnet-core-classic-node-javascript\nWhich was neat because it was celebrating pi day by using dotnetcore, dotnet classic, and node to calculate pi using the Leibniz formula for π and I like geeky things like that. This post isn’t about what that is - but if you’re interested visit that link and check it out!\nWho was the largest knight at King Arthur’s Round table? Sir Cumference! He got that way from eating too much pi! – Unknown\nThe point of the article was to showcase how much faster dotnetcore was than nodejs. Which it seemed to.. until I looked at their github and noticed that the code wasn’t necessarily comparing apples to apples.\nIn dotnetcore they used the standard library and for nodejs they installed and included mathjs [] and moment for performing some small math and date functions. Libraries like this are both the boon and bane of node.js. It was completely possible to use JavaScript’s native Math and Date api however, for ease of use, the authors chose to install these two libraries. They make programming in node easy while sacrificing some performance - a great tradeoff in a lot of circumstances!\nHowever, I digress. Long story short - using node v10.6 and refactoring the libraries back to the standard library, I was able to bring the node performance from ~9 seconds in windows to ~4 seconds which isn’t as good as dotnetcore on windows but is much faster than original.\nThis led me to wonder - how would other languages perform? Golang has been a personal favourite of mine for a while despite not having anything in any intense form of production using it - so I started there and was … disappointed.\nIt was about 10 seconds - so I did what any rational programmer with 2 small kids would do after they go to bed. I tried the other languages I know how to program in!\nLanguage Version Time (ms) Golang 1.11.2 10 852 Node 12.3 897 C C11 867 Python 2.7.15 25 704 Dotnet Core (C#) 2.2.0 1 231 Java 1.8.0_818 7 816 My golang sweetheart fell by the wayside for this test :(\nMy upgraded version of Node however killed it! I originally ran it with node v10.6 and it was ~ 3.4 seconds then upgraded node just to see. Now I don’t feel like downgrading node so I’ll leave that up to whoever happens to stumble across this to play with.\nI’m also not going to try it on many vm’s because I’m truthfully much to lazy for that this evening however if you are so interested, I ran these on OSX 10.\nI just wanted to share how differently different languages handle the same sort of calculations. I’m curious to know that if I used Oracle’s Java vs OpenJDK’s Java if the performance would have increased?\nThat’s about all I have to say about this so now I do as my young ones have done - and hit the hay!\n","wordCount":"583","inLanguage":"en","datePublished":"2019-05-22T09:51:39Z","dateModified":"2019-05-22T09:51:39Z","author":{"@type":"Person","name":"James D Hughes"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/"},"publisher":{"@type":"Organization","name":"James Hughes","logo":{"@type":"ImageObject","url":"https://blog.jimdhughes.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jimdhughes.com/ accesskey=h title="James Hughes (Alt + H)">James Hughes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Benchmarking a pi calculation for fun</h1><div class=post-meta><span title='2019-05-22 09:51:39 +0000 UTC'>May 22, 2019</span>&nbsp;·&nbsp;James D Hughes</div></header><div class=post-content><p>Dotnet Core, Golang, Node, C, Java, Python.</p><p>This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js. As is typical when things like these arise, our team&rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - &ldquo;Do you think cypress would be faster than selenium?&rdquo;</p><p>An article that came up in slack is here: <a href=https://www.skylinetechnologies.com/Blog/Skyline-Blog/March_2018/pi-day-compare-dotnet-core-classic-node-javascript>https://www.skylinetechnologies.com/Blog/Skyline-Blog/March_2018/pi-day-compare-dotnet-core-classic-node-javascript</a></p><p>Which was neat because it was celebrating pi day by using dotnetcore, dotnet classic, and node to calculate pi using the <a href=https://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80>Leibniz formula for π</a> and I like geeky things like that. This post isn&rsquo;t about what that is - but if you&rsquo;re interested visit that link and check it out!</p><blockquote><p>Who was the largest knight at King Arthur&rsquo;s Round table? Sir Cumference!
He got that way from eating too much pi!
&ndash; Unknown</p></blockquote><p>The point of the article was to showcase how much faster dotnetcore was than nodejs. Which it seemed to.. until I looked at their github and noticed that the code wasn&rsquo;t necessarily comparing apples to apples.</p><p>In dotnetcore they used the standard library and for nodejs they installed and included <a href=https://mathjs.org/>mathjs</a> [] and <a href=https://momentjs.com/>moment</a> for performing some small math and date functions. Libraries like this are both the boon and bane of node.js. It was completely possible to use JavaScript&rsquo;s native Math and Date api however, for ease of use, the authors chose to install these two libraries. They make programming in node <em>easy</em> while sacrificing some performance - a great tradeoff in a lot of circumstances!</p><p>However, I digress. Long story short - using node v10.6 and refactoring the libraries back to the standard library, I was able to bring the node performance from ~9 seconds in windows to ~4 seconds which isn&rsquo;t as good as dotnetcore on windows but is much faster than original.</p><p>This led me to wonder - how would other languages perform? Golang has been a personal favourite of mine for a while despite not having anything in any intense form of production using it - so I started there and was &mldr; disappointed.</p><p>It was about 10 seconds - so I did what any rational programmer with 2 small kids would do after they go to bed. I tried the other languages I know how to program in!</p><table><thead><tr><th>Language</th><th>Version</th><th>Time (ms)</th></tr></thead><tbody><tr><td>Golang</td><td>1.11.2</td><td>10 852</td></tr><tr><td>Node</td><td>12.3</td><td>897</td></tr><tr><td>C</td><td>C11</td><td>867</td></tr><tr><td>Python</td><td>2.7.15</td><td>25 704</td></tr><tr><td>Dotnet Core (C#)</td><td>2.2.0</td><td>1 231</td></tr><tr><td>Java</td><td>1.8.0_818</td><td>7 816</td></tr></tbody></table><p>My golang sweetheart fell by the wayside for this test :(</p><p>My upgraded version of Node however killed it! I originally ran it with node v10.6 and it was ~ 3.4 seconds then upgraded node just to see. Now I don&rsquo;t feel like downgrading node so I&rsquo;ll leave that up to whoever happens to stumble across this to play with.</p><p>I&rsquo;m also not going to try it on many vm&rsquo;s because I&rsquo;m truthfully much to lazy for that this evening however if you are so interested, I ran these on OSX 10.</p><p>I just wanted to share how differently different languages handle the same sort of calculations. I&rsquo;m curious to know that if I used Oracle&rsquo;s Java vs OpenJDK&rsquo;s Java if the performance would have increased?</p><p>That&rsquo;s about all I have to say about this so now I do as my young ones have done - and hit the hay!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jimdhughes.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jimdhughes.com/tags/golang/>Golang</a></li><li><a href=https://blog.jimdhughes.com/tags/java/>Java</a></li><li><a href=https://blog.jimdhughes.com/tags/python/>Python</a></li><li><a href=https://blog.jimdhughes.com/tags/c/>C</a></li><li><a href=https://blog.jimdhughes.com/tags/programming/>Programming</a></li><li><a href=https://blog.jimdhughes.com/tags/pi/>Pi</a></li><li><a href=https://blog.jimdhughes.com/tags/algorithms/>Algorithms</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jimdhughes.com/>James Hughes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>