<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go - Micro-services and Embedded Databases [Part 2] | James Hughes</title>
<meta name=keywords content="golang"><meta name=description content='If you haven&rsquo;t already, check out Part 1[!]
First things first - let&rsquo;s make these responses something machine readable instead of just some plain text! That&rsquo;s a nice and easy way to dive back into the code!
We are going to create 2 new structs in the router.go file to declare how the app is going to return Errors and Standard responses.
package main

// ...

type ApiErrorResponse struct {
	Error string `json:"error"`
}

type ApiStandardResponse struct {
	Payload interface{} `json:"payload"`
}
This is menial, but it helps our responses have a bit more structure.  The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly.  The ApiStandardResponse is pretty well the same except we have an interface{} type on the payload.  This is so that we can return any type of data.   The response will be dependent on what is being returned by the handler.  Next let&rsquo;s update our WriteError function to use this new struct'><meta name=author content="James D Hughes"><link rel=canonical href=https://blog.jimdhughes.com/posts/2018/go-micro-services-and-embedded-databases-part-2/><meta name=google-site-verification content="G-0ET0VYDXCL"><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jimdhughes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jimdhughes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jimdhughes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jimdhughes.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jimdhughes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.jimdhughes.com/posts/2018/go-micro-services-and-embedded-databases-part-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.jimdhughes.com/posts/2018/go-micro-services-and-embedded-databases-part-2/"><meta property="og:site_name" content="James Hughes"><meta property="og:title" content="Go - Micro-services and Embedded Databases [Part 2]"><meta property="og:description" content='If you haven’t already, check out Part 1[!]
First things first - let’s make these responses something machine readable instead of just some plain text! That’s a nice and easy way to dive back into the code!
We are going to create 2 new structs in the router.go file to declare how the app is going to return Errors and Standard responses.
package main // ... type ApiErrorResponse struct { Error string `json:"error"` } type ApiStandardResponse struct { Payload interface{} `json:"payload"` } This is menial, but it helps our responses have a bit more structure. The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly. The ApiStandardResponse is pretty well the same except we have an interface{} type on the payload. This is so that we can return any type of data. The response will be dependent on what is being returned by the handler. Next let’s update our WriteError function to use this new struct'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-09-24T09:51:32+00:00"><meta property="article:modified_time" content="2018-09-24T09:51:32+00:00"><meta property="article:tag" content="Golang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go - Micro-services and Embedded Databases [Part 2]"><meta name=twitter:description content='If you haven&rsquo;t already, check out Part 1[!]
First things first - let&rsquo;s make these responses something machine readable instead of just some plain text! That&rsquo;s a nice and easy way to dive back into the code!
We are going to create 2 new structs in the router.go file to declare how the app is going to return Errors and Standard responses.
package main

// ...

type ApiErrorResponse struct {
	Error string `json:"error"`
}

type ApiStandardResponse struct {
	Payload interface{} `json:"payload"`
}
This is menial, but it helps our responses have a bit more structure.  The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly.  The ApiStandardResponse is pretty well the same except we have an interface{} type on the payload.  This is so that we can return any type of data.   The response will be dependent on what is being returned by the handler.  Next let&rsquo;s update our WriteError function to use this new struct'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Go - Micro-services and Embedded Databases [Part 2]","item":"https://blog.jimdhughes.com/posts/2018/go-micro-services-and-embedded-databases-part-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go - Micro-services and Embedded Databases [Part 2]","name":"Go - Micro-services and Embedded Databases [Part 2]","description":"If you haven\u0026rsquo;t already, check out Part 1[!]\nFirst things first - let\u0026rsquo;s make these responses something machine readable instead of just some plain text! That\u0026rsquo;s a nice and easy way to dive back into the code!\nWe are going to create 2 new structs in the router.go file to declare how the app is going to return Errors and Standard responses.\npackage main // ... type ApiErrorResponse struct { Error string `json:\u0026#34;error\u0026#34;` } type ApiStandardResponse struct { Payload interface{} `json:\u0026#34;payload\u0026#34;` } This is menial, but it helps our responses have a bit more structure. The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly. The ApiStandardResponse is pretty well the same except we have an interface{} type on the payload. This is so that we can return any type of data. The response will be dependent on what is being returned by the handler. Next let\u0026rsquo;s update our WriteError function to use this new struct\n","keywords":["golang"],"articleBody":"If you haven’t already, check out Part 1[!]\nFirst things first - let’s make these responses something machine readable instead of just some plain text! That’s a nice and easy way to dive back into the code!\nWe are going to create 2 new structs in the router.go file to declare how the app is going to return Errors and Standard responses.\npackage main // ... type ApiErrorResponse struct { Error string `json:\"error\"` } type ApiStandardResponse struct { Payload interface{} `json:\"payload\"` } This is menial, but it helps our responses have a bit more structure. The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly. The ApiStandardResponse is pretty well the same except we have an interface{} type on the payload. This is so that we can return any type of data. The response will be dependent on what is being returned by the handler. Next let’s update our WriteError function to use this new struct\nfunc WriteError(w http.ResponseWriter, statusCode int, err error) { w.Header().Set(\"Content-Type\", \"application/json; charset=UTF-8\") w.WriteHeader(statusCode) response := ApiErrorResponse{Error: err.Error()} json.NewEncoder(w).Encode(response) } Here we take the error, make a new response object and then encode it as a json format and send it back to the requester. Easy as pie!\nTaking a leaf out of our WriteError book, let’s implement a WriteResponse function to handle all the good responses! It’s going to look a lot the same as the WriteError function.\nfunc WriteResponse(w http.ResponseWriter, statusCode int, payload interface{}) { w.Header().Set(\"Content-Type\", \"application/json; charset=UTF-8\") w.WriteHeader(statusCode) response := ApiStandardResponse{Payload: payload} json.NewEncoder(w).Encode(response) } Again, pretty straight forward. You should update all of your response lines that were previously just fmt.Fprintf(w, …) with the WriteResponse function. Hint - they are in the HandleRegistration and HandleLogin functions!\nNow on to some real functionality. Tokens!\nWe’re going to return a token from our Login function. This is going to contain some user information such as their Email and ID. In a real app you could return some permission grants for your apps or user roles, but we’re not going to be that sophisticated here. Make a new file called tokenHandler.go\npackage main const ( secretKey = \"asupersecretekeythatshouldntbehardcodedhere\" ) type ITokenService interface { CreateToken(user User) (string, error) ValidateToken(token string) (interface{}, error) } type TokenService struct{} var TS ITokenService func (t *TokenService) CreateToken(user User) (string, error) { return \"\", nil } func (t *TokenService) ValidateToken(token string) (interface{}, error) { return User{}, nil } This should be all we need as a scaffold. We create an interface as the contract for the service and then implement a struct that will essentially implement the ITokenService interface. We have method stubs to handle the creation of a token from a user and the validation of a token.\nIn contrast to my last post, we’re going to do our development TDD style this time around.\nFirstly we need to initialize our TokenService in our TestMain function (found in db.go)\nfunc TestMain(m *testing.M) { DB = \u0026DBClient{} TS = \u0026TokenService{} DB.Initialize(\"./bolt-test.db\") retCode := m.Run() os.Remove(\"./bolt-test.db\") os.Exit(retCode) } Next comes the test file for the Token Service tokenService_test.go\npackage main import ( \"testing\" ) func TestCreateTokenFromNotValidUser(t *testing.T) { user := User{} token, err := TS.CreateToken(user) if err == nil { t.Errorf(\"Token should not be created for an empty user\") return } if token != \"\" { t.Errorf(\"Error should have been thrown as token cannot be created\") return } } func TestCreateTokenFromValidUser(t *testing.T) { user := User{Email: \"tokentester@domain.com\", Password: \"password\"} DB.CreateUser(user) // we test this elsewhere so assume it works. see db_test.go // ... I'm Stuck! } Yep. I’m stuck!\nThis is why TDD is good. It forces you to develop some better code. The original flow that I had planned was that the Login function would just return a string value (the token) which isn’t necessarily wrong, however for logical testing it makes life a bit harder than it has to be!\nWe have code to get a user by email twice in this application already. Once in the Login function and once in the CheckUserExists function. So let’s refactor this repeated code into a new function called GetUserByEmail in the db.go file.\npackage main type IDBClient interface { Initialize(filepath string) Open() Close() CreateUser(u User) (bool, error) Login(email, password string) (string, error) CheckUserIsNew(email string) (bool, error) // Add to the interface GetUserByEmail(email string) (User, error) } // ... func (db *DBClient) GetUserByEmail(email string) (User, error) { db.Open() defer db.Close() user := User{} err := db.client.View(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(usersBucketName)) userBytes := b.Get([]byte(email)) if userBytes == nil { return nil } err := json.Unmarshal(userBytes, \u0026user) if err != nil { return err } return nil }) if err != nil { return User{}, err } return user, nil } And now that we have our helper function we can rebuild our CheckUserExists and Login functions!\nfunc (db *DBClient) CheckUserIsNew(email string) (bool, error) { user, err := db.GetUserByEmail(email) if err != nil { log.Printf(\"%s\", err) return false, err } if user.ID != \"\" { return false, fmt.Errorf(\"User Exists with email %s\", email) } return true, nil } func (db *DBClient) Login(email, password string) (string, error) { user, err := db.GetUserByEmail(email) if err != nil { return \"Nope\", err } err = user.CheckPassword(password) if err != nil { return \"nope\", err } return \"yep\", nil } func (db *DBClient) CreateUser(u User) (bool, error) { isNew, err := db.CheckUserIsNew(u.Email) if err != nil || isNew == false { return false, err } db.Open() defer db.Close() err = db.client.Update(func(txn *bolt.Tx) error { // ... } With this new functionality, we have to make some changes to our original code. We don’t need to open the database in the Login function or the CheckUserExists function. This also means though that when we get to our CreateUser we need to move the db.Open() and defer db.Close() calls to after the CheckUserIsNew function as we end up opening a database connection again.\nWe should test the new GetUserByEmail function so add a new test in db_test.go\n// ... func TestGetUserByEmailInvalidEmail(t *testing.T) { user, err := DB.GetUserByEmail(\"invalidemail@somedomain.com\") if err != nil { t.Errorf(err.Error()) } if user.ID != \"\" { t.Errorf(\"No user should have been returned\") } } func TestGetUserByEmailValidEmail(t *testing.T) { user, err := DB.GetUserByEmail(\"test@domain.com\") if err != nil { t.Error(err.Error()) } if user.Email == \"\" { t.Error(\"Expected to get user but got an empty user\") } if user.Email != \"test@domain.com\" { t.Errorf(\"Returned a user other than expected\") } } That’s much better! Run our tests again to make sure we haven’t broken any functionality using go test. The only test that should be failing is the one we were previously stuck on! This means that we haven’t broken the system! Woot!! We don’t have to stay late tonight!\nFull Disclosure: My tests were failing when I first wrote the changes. I got to fix them before publishing. Tests are good.\nNow that we’ve made those changes, we can implement that test and continue on writing some more!\n// ... func TestCreateTokenFromValidUser(t *testing.T) { user := User{Email: \"tokentester@domain.com\", Password: \"password\"} DB.CreateUser(user) // we test this elsewhere so assume it works. see db_test.go user, _ = DB.GetUserByEmail(user.Email) //we can ignore the error as we test this elsewhere token, err := TS.CreateToken(user) if err == nil { fmt.Errorf(\"Token could not be created for user: %s\", err) } if token == \"\" { fmt.Errorf(\"Empty token was returned. Expected a token as a string\") } } Let’s run our tests!\nThey better all fail. If they don’t then my logic might be worse than I originally anticipated.\nDisclosure again: I got to run these before posting so I look smart :) Testing saves the day again!\nNow onto implementing our CreateToken function. I’m using the package \"github.com/dgrijalva/jwt-go\" because it’s the first that pops up when you type ‘golang’ and ‘jwt’ into google (and the Auth0 blog wrote a post on it as well, so you know it’s good)\n// Creates a new Token for a User func (t *TokenService) CreateToken(user User) (string, error) { safeUser := UserSafe{} safeUser.ID = user.ID safeUser.Email = user.Email token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{ \"sub\": user, \"exp\": time.Now().Add(time.Hour).Unix(), }) // TODO: Remove hardcoded signed string tokenString, err := token.SignedString([]byte(secretKey)) if err != nil { log.Println(\"Error signing token: \", err) return \"\", err } return tokenString, nil } In model.go I guess we should make the SafeUser struct. This is just a helper struct to make sure we don’t hand the passwords back to anyone that shouldn’t have access to them.\n// ... type UserSafe struct { ID string `json:\"id\"` Email string `json:\"email\"` } Here we are parsing the interesting fields of our User into a SafeUser struct. I’ve read some blogs saying that you can pass around the password through your microservice architecture but I don’t prescribe to that school of thought. The less often your passwords are exposed on the wire the less chance you have of accidentally leaking it. If you’re making this service the trusted source of user authentication and authorization for your app, no other component needs to know what their password is.\nNext we create a token by signing it using the HS256 method with the claims sub as the safeUser data and exp as the expiration date. In a full implementation you may also issue a refresh token here but I’m not interested in handling that for this post.\nWe then take the token and stringify it then return it to the calling function! run go test to make sure we have two less failing test now! Wait! We are still not handling the scenario where we create a token for a user struct thats empty! That’s illogical! Let’s fix that really quickly.\nfunc (t *TokenService) CreateToken(user User) (string, error) { if (User{}) == user { log.Printf(\"%s\", user.Email) return \"\", fmt.Errorf(\"Cannot create token for empty user\") } // ... } In keeping with our TDD approach, let’s whip up some scenarios to test our ValidateToken function. We should at least try to validate an invalid token, and then validate a valid token. Back to tokenService_test.go\nfunc TestValidateTokenFromInvalidToken(t *testing.T) { token := \"thisisNOTatoken\" payload, err := TS.ValidateToken(token) if err == nil { t.Errorf(\"Expected an error to be thrown as token is not valid\") } if payload != nil { t.Errorf(\"Expected no user to be returned\") } } func TestValidateTokenFromValidToken(t *testing.T) { user, err := DB.GetUserByEmail(\"tokentester@domain.com\") if err != nil { t.Error(err) } if user.ID == \"\" { t.Errorf(\"Expected to get a user. Got none\") } token, err := TS.CreateToken(user) if err != nil { t.Error(err) } if token == \"\" { t.Error(\"Got an empty token when expecting a real token\") } payload, err := TS.ValidateToken(token) if err != nil { t.Error(err) } if payload == nil { t.Error(\"Expected to get a payload, got none\") } } Now that we have our extensive tests planned out, we can implement the feature!\nfunc (t *TokenService) ValidateToken(tokenString string) (interface{}, error) { claims := jwt.MapClaims{} token, err := jwt.ParseWithClaims(tokenString, \u0026claims, func(token *jwt.Token) (interface{}, error) { return []byte(secretKey), nil }) if err != nil { return nil, err } if token.Valid { return claims[\"sub\"], nil } else if ve, ok := err.(*jwt.ValidationError); ok { if ve.Errors\u0026jwt.ValidationErrorMalformed != 0 { return false, fmt.Errorf(\"Malformed Token\") } else if ve.Errors\u0026(jwt.ValidationErrorExpired|jwt.ValidationErrorNotValidYet) != 0 { // Token is either expired or not active yet return false, fmt.Errorf(\"Token is Expired\") } else { return false, fmt.Errorf(\"Couldn't handle the token\") } } else { return false, fmt.Errorf(\"Error handling token: %v\", err) } } There we go! We try to parse the token and if it succeeds, we return the subject of the token. If it’s expired, or malformed, or the like then we return some errors! We could make this more bulletproof probably by returning a UserSafe object as opposed to an interface, but this post is getting long again and I’m getting lazy :)\nRun our tests and everything should look good!\nFinally! We’re going to implement the HandleValidateToken endpoint! It’s been a long fought battle but here we go! We’re going to be more strict with our token payload so first we declare a struct for it, and then implement the function.\n// ... type TokenPayload struct { Token string `json:\"token\"` } // ... func HandleValidateToken(w http.ResponseWriter, r *http.Request) { var Token TokenPayload err := json.NewDecoder(r.Body).Decode(\u0026Token) if err != nil { fmt.Fprintf(w, \"Error Decoding Body: %v\", err.Error()) return } payload, err := TS.ValidateToken(Token.Token) if err != nil { fmt.Fprintf(w, \"Error Decoding Token: %v\", err.Error()) return } WriteResponse(w, http.StatusOK, payload) } You’ve got some errors though. We didn’t initialize TS in our app. Go into main.go and add a InitializeTokenService function and call it from main:\n// ... func main() { fmt.Println(\"Hello, World!\") InitializeDatabase() InitializeTokenService() InitializeHttpServer() } // ... func InitializeTokenService() { TS = \u0026TokenService{} } Finally, to bring it all together, we need to update our Login function to return something meaningful (a token) so update the function like so:\nfunc (db *DBClient) Login(email, password string) (string, error) { db.Open() defer db.Close() var user User err := db.client.View(func(tx *bolt.Tx) error { b := tx.Bucket([]byte(usersBucketName)) userBytes := b.Get([]byte(email)) json.Unmarshal(userBytes, \u0026user) err := user.CheckPassword(password) if err != nil { log.Printf(\"ERROR: %s\", err) log.Printf(\"Invalid Login Attempt for User: %s\", email) return fmt.Errorf(\"Invalid Email/Password Combnation\") } return nil }) if err != nil { return \"\", err } token, err := TS.CreateToken(user) if err != nil { return \"\", err } return token, nil } Great Success! We’ve all learned something here (hopefully). I’ve learned how to make something actually useful with Go. You’ve hopefully learned it as well. We’ve put together a service that is built using go, with an embedded database, and has just one small job to perform. It’s got some tests so you can update code and feel more confident about it, and you could call it from other apps on your network.\nThere’s a bunch of security things you should do before using this in a production environment such as:\nLimiting hosts and ports that can make requests to the server (CORS) Setting up SSL certificates to host Disabling non-SSL/TLS connections Automatic backups of your database file Refactoring your secrets into a config file or to CLI variables Implementing functionality to revoke token access for a specific user Add in some permissions to the user to have some granularity for controls within your suite of apps Hopefully these posts have been as insightful for you to read as me to write! I’ll have the code up on my github in the near future.\n","wordCount":"2412","inLanguage":"en","datePublished":"2018-09-24T09:51:32Z","dateModified":"2018-09-24T09:51:32Z","author":{"@type":"Person","name":"James D Hughes"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jimdhughes.com/posts/2018/go-micro-services-and-embedded-databases-part-2/"},"publisher":{"@type":"Organization","name":"James Hughes","logo":{"@type":"ImageObject","url":"https://blog.jimdhughes.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jimdhughes.com/ accesskey=h title="James Hughes (Alt + H)">James Hughes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Go - Micro-services and Embedded Databases [Part 2]</h1><div class=post-meta><span title='2018-09-24 09:51:32 +0000 UTC'>September 24, 2018</span>&nbsp;·&nbsp;James D Hughes</div></header><div class=post-content><p>If you haven&rsquo;t already, check out <a href=https://blog.jimdhughes.com/go-micro-services-and-embedded-databases/>Part 1</a>[!]</p><p>First things first - let&rsquo;s make these responses something machine readable instead of just some plain text! That&rsquo;s a nice and easy way to dive back into the code!</p><p>We are going to create 2 new structs in the <code>router.go</code> file to declare how the app is going to return Errors and Standard responses.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ApiErrorResponse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Error</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;error&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ApiStandardResponse</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Payload</span> <span style=color:#66d9ef>interface</span>{} <span style=color:#e6db74>`json:&#34;payload&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is menial, but it helps our responses have a bit more structure. The first simply returns an error message as a string value. We will assume that our handlers will set the http response status accordingly. The <code>ApiStandardResponse</code> is pretty well the same except we have an <code>interface{}</code> type on the payload. This is so that we can return any type of data. The response will be dependent on what is being returned by the handler. Next let&rsquo;s update our <code>WriteError</code> function to use this new struct</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WriteError</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>statusCode</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;application/json; charset=UTF-8&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>statusCode</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>response</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ApiErrorResponse</span>{<span style=color:#a6e22e>Error</span>: <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>()}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>w</span>).<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>response</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we take the error, make a new response object and then encode it as a json format and send it back to the requester. Easy as pie!</p><p>Taking a leaf out of our <code>WriteError</code> book, let&rsquo;s implement a <code>WriteResponse</code> function to handle all the good responses! It&rsquo;s going to look a lot the same as the <code>WriteError</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>WriteResponse</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>statusCode</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>payload</span> <span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;application/json; charset=UTF-8&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>WriteHeader</span>(<span style=color:#a6e22e>statusCode</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>response</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ApiStandardResponse</span>{<span style=color:#a6e22e>Payload</span>: <span style=color:#a6e22e>payload</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>w</span>).<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>response</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again, pretty straight forward. You should update all of your response lines that were previously just fmt.Fprintf(w, &mldr;) with the WriteResponse function. Hint - they are in the <code>HandleRegistration</code> and <code>HandleLogin</code> functions!</p><p>Now on to some real functionality. Tokens!</p><p>We&rsquo;re going to return a token from our <code>Login</code> function. This is going to contain some user information such as their Email and ID. In a real app you could return some permission grants for your apps or user roles, but we&rsquo;re not going to be that sophisticated here. Make a new file called <code>tokenHandler.go</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>secretKey</span> = <span style=color:#e6db74>&#34;asupersecretekeythatshouldntbehardcodedhere&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ITokenService</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>token</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TokenService</span> <span style=color:#66d9ef>struct</span>{}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>TS</span> <span style=color:#a6e22e>ITokenService</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TokenService</span>) <span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TokenService</span>) <span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>token</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>User</span>{}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This should be all we need as a scaffold. We create an interface as the contract for the service and then implement a struct that will essentially implement the ITokenService interface. We have method stubs to handle the creation of a token from a user and the validation of a token.</p><p>In contrast to my last post, we&rsquo;re going to do our development TDD style this time around.</p><p>Firstly we need to initialize our TokenService in our TestMain function (found in db.go)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestMain</span>(<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>M</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DB</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>DBClient</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TS</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TokenService</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>Initialize</span>(<span style=color:#e6db74>&#34;./bolt-test.db&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>retCode</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Remove</span>(<span style=color:#e6db74>&#34;./bolt-test.db&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Exit</span>(<span style=color:#a6e22e>retCode</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next comes the test file for the Token Service <code>tokenService_test.go</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;testing&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestCreateTokenFromNotValidUser</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Token should not be created for an empty user&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>token</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Error should have been thrown as token cannot be created&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestCreateTokenFromValidUser</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{<span style=color:#a6e22e>Email</span>: <span style=color:#e6db74>&#34;tokentester@domain.com&#34;</span>, <span style=color:#a6e22e>Password</span>: <span style=color:#e6db74>&#34;password&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>user</span>) <span style=color:#75715e>// we test this elsewhere so assume it works. see db_test.go</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... I&#39;m Stuck!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yep. I&rsquo;m stuck!</p><p>This is why TDD is good. It forces you to develop some better code. The original flow that I had planned was that the Login function would just return a string value (the token) which isn&rsquo;t necessarily wrong, however for logical testing it makes life a bit harder than it has to be!</p><p>We have code to get a user by email twice in this application already. Once in the <code>Login</code> function and once in the <code>CheckUserExists</code> function. So let&rsquo;s refactor this repeated code into a new function called <code>GetUserByEmail</code> in the <code>db.go</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>IDBClient</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Initialize</span>(<span style=color:#a6e22e>filepath</span> <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Open</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>u</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Login</span>(<span style=color:#a6e22e>email</span>, <span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CheckUserIsNew</span>(<span style=color:#a6e22e>email</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add to the interface</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#a6e22e>email</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBClient</span>) <span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#a6e22e>email</span> <span style=color:#66d9ef>string</span>) (<span style=color:#a6e22e>User</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Open</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#a6e22e>usersBucketName</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>userBytes</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Get</span>([]byte(<span style=color:#a6e22e>email</span>))
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>userBytes</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>userBytes</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>User</span>{}, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>user</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And now that we have our helper function we can rebuild our <code>CheckUserExists</code> and <code>Login</code> functions!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBClient</span>) <span style=color:#a6e22e>CheckUserIsNew</span>(<span style=color:#a6e22e>email</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#a6e22e>email</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;User Exists with email %s&#34;</span>, <span style=color:#a6e22e>email</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBClient</span>) <span style=color:#a6e22e>Login</span>(<span style=color:#a6e22e>email</span>, <span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#a6e22e>email</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Nope&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>CheckPassword</span>(<span style=color:#a6e22e>password</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;nope&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;yep&#34;</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBClient</span>) <span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>u</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>bool</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isNew</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>CheckUserIsNew</span>(<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Email</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>isNew</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>false</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Open</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>txn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this new functionality, we have to make some changes to our original code. We don&rsquo;t need to open the database in the <code>Login</code> function or the <code>CheckUserExists</code> function. This also means though that when we get to our <code>CreateUser</code> we need to move the <code>db.Open()</code> and <code>defer db.Close()</code> calls to after the <code>CheckUserIsNew</code> function as we end up opening a database connection again.</p><p>We should test the new <code>GetUserByEmail</code> function so add a new test in <code>db_test.go</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestGetUserByEmailInvalidEmail</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#e6db74>&#34;invalidemail@somedomain.com&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;No user should have been returned&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestGetUserByEmailValidEmail</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#e6db74>&#34;test@domain.com&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Email</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;Expected to get user but got an empty user&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Email</span> <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#34;test@domain.com&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Returned a user other than expected&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>That&rsquo;s much better! Run our tests again to make sure we haven&rsquo;t broken any functionality using <code>go test</code>. The only test that should be failing is the one we were previously stuck on! This means that we haven&rsquo;t broken the system! Woot!! We don&rsquo;t have to stay late tonight!</p><p><strong>Full Disclosure: My tests were failing when I first wrote the changes. I got to fix them before publishing. Tests are good.</strong></p><p>Now that we&rsquo;ve made those changes, we can implement that test and continue on writing some more!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestCreateTokenFromValidUser</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>User</span>{<span style=color:#a6e22e>Email</span>: <span style=color:#e6db74>&#34;tokentester@domain.com&#34;</span>, <span style=color:#a6e22e>Password</span>: <span style=color:#e6db74>&#34;password&#34;</span>}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>user</span>)                     <span style=color:#75715e>// we test this elsewhere so assume it works. see db_test.go</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Email</span>) <span style=color:#75715e>//we can ignore the error as we test this elsewhere</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Token could not be created for user: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>token</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Empty token was returned. Expected a token as a string&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Let&rsquo;s run our tests!</p><p>They better all fail. If they don&rsquo;t then my logic might be worse than I originally anticipated.</p><p><strong>Disclosure again: I got to run these before posting so I look smart :) Testing saves the day again!</strong></p><p>Now onto implementing our <code>CreateToken</code> function. I&rsquo;m using the package <code>"github.com/dgrijalva/jwt-go"</code> because it&rsquo;s the first that pops up when you type &lsquo;golang&rsquo; and &lsquo;jwt&rsquo; into google (and the Auth0 blog wrote a post on it as well, so you know it&rsquo;s good)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Creates a new Token for a User</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TokenService</span>) <span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>safeUser</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>UserSafe</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>safeUser</span>.<span style=color:#a6e22e>ID</span> = <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>safeUser</span>.<span style=color:#a6e22e>Email</span> = <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Email</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>NewWithClaims</span>(<span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>SigningMethodHS256</span>, <span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>MapClaims</span>{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;sub&#34;</span>: <span style=color:#a6e22e>user</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;exp&#34;</span>: <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>().<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Hour</span>).<span style=color:#a6e22e>Unix</span>(),
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// TODO: Remove hardcoded signed string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tokenString</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>token</span>.<span style=color:#a6e22e>SignedString</span>([]byte(<span style=color:#a6e22e>secretKey</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Error signing token: &#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tokenString</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In <code>model.go</code> I guess we should make the SafeUser struct. This is just a helper struct to make sure we don&rsquo;t hand the passwords back to anyone that shouldn&rsquo;t have access to them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>UserSafe</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ID</span>    <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;id&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Email</span> <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;email&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here we are parsing the interesting fields of our User into a SafeUser struct. I&rsquo;ve read some blogs saying that you can pass around the password through your microservice architecture but I don&rsquo;t prescribe to that school of thought. The less often your passwords are exposed on the wire the less chance you have of accidentally leaking it. If you&rsquo;re making this service the trusted source of user authentication and authorization for your app, no other component needs to know what their password is.</p><p>Next we create a token by signing it using the HS256 method with the claims <code>sub</code> as the safeUser data and <code>exp</code> as the expiration date. In a full implementation you may also issue a refresh token here but I&rsquo;m not interested in handling that for this post.</p><p>We then take the token and stringify it then return it to the calling function! run <code>go test</code> to make sure we have two less failing test now! Wait! We are still not handling the scenario where we create a token for a user struct thats empty! That&rsquo;s illogical! Let&rsquo;s fix that really quickly.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TokenService</span>) <span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>User</span>{}) <span style=color:#f92672>==</span> <span style=color:#a6e22e>user</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s&#34;</span>, <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Email</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Cannot create token for empty user&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In keeping with our TDD approach, let&rsquo;s whip up some scenarios to test our <code>ValidateToken</code> function. We should at least try to validate an invalid token, and then validate a valid token. Back to <code>tokenService_test.go</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestValidateTokenFromInvalidToken</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span> <span style=color:#f92672>:=</span> <span style=color:#e6db74>&#34;thisisNOTatoken&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>payload</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>token</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Expected an error to be thrown as token is not valid&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>payload</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Expected no user to be returned&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>TestValidateTokenFromValidToken</span>(<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>testing</span>.<span style=color:#a6e22e>T</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>DB</span>.<span style=color:#a6e22e>GetUserByEmail</span>(<span style=color:#e6db74>&#34;tokentester@domain.com&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>ID</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Expected to get a user. Got none&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>token</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&#34;</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;Got an empty token when expecting a real token&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>payload</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>token</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>payload</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#e6db74>&#34;Expected to get a payload, got none&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now that we have our extensive tests planned out, we can implement the feature!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>t</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>TokenService</span>) <span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>tokenString</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>claims</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>MapClaims</span>{}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>ParseWithClaims</span>(<span style=color:#a6e22e>tokenString</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>claims</span>, <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>token</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>Token</span>) (<span style=color:#66d9ef>interface</span>{}, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> []byte(<span style=color:#a6e22e>secretKey</span>), <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>token</span>.<span style=color:#a6e22e>Valid</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>claims</span>[<span style=color:#e6db74>&#34;sub&#34;</span>], <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ve</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>err</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>ValidationError</span>); <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ve</span>.<span style=color:#a6e22e>Errors</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>ValidationErrorMalformed</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Malformed Token&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ve</span>.<span style=color:#a6e22e>Errors</span><span style=color:#f92672>&amp;</span>(<span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>ValidationErrorExpired</span>|<span style=color:#a6e22e>jwt</span>.<span style=color:#a6e22e>ValidationErrorNotValidYet</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Token is either expired or not active yet</span>
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Token is Expired&#34;</span>)
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Couldn&#39;t handle the token&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Error handling token: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There we go! We try to parse the token and if it succeeds, we return the subject of the token. If it&rsquo;s expired, or malformed, or the like then we return some errors! We could make this more bulletproof probably by returning a UserSafe object as opposed to an interface, but this post is getting long again and I&rsquo;m getting lazy :)</p><p>Run our tests and everything should look good!</p><p>Finally! We&rsquo;re going to implement the <code>HandleValidateToken</code> endpoint! It&rsquo;s been a long fought battle but here we go! We&rsquo;re going to be more strict with our token payload so first we declare a struct for it, and then implement the function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>TokenPayload</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Token</span>  <span style=color:#66d9ef>string</span> <span style=color:#e6db74>`json:&#34;token&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>HandleValidateToken</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>Token</span> <span style=color:#a6e22e>TokenPayload</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewDecoder</span>(<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Body</span>).<span style=color:#a6e22e>Decode</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Token</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error Decoding Body: %v&#34;</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>payload</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>ValidateToken</span>(<span style=color:#a6e22e>Token</span>.<span style=color:#a6e22e>Token</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprintf</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;Error Decoding Token: %v&#34;</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>())
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>WriteResponse</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusOK</span>, <span style=color:#a6e22e>payload</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You&rsquo;ve got some errors though. We didn&rsquo;t initialize TS in our app. Go into main.go and add a <code>InitializeTokenService</code> function and call it from main:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Hello, World!&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>InitializeDatabase</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>InitializeTokenService</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>InitializeHttpServer</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>InitializeTokenService</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TS</span> = <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>TokenService</span>{}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, to bring it all together, we need to update our <code>Login</code> function to return something meaningful (a token) so update the function like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DBClient</span>) <span style=color:#a6e22e>Login</span>(<span style=color:#a6e22e>email</span>, <span style=color:#a6e22e>password</span> <span style=color:#66d9ef>string</span>) (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Open</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>user</span> <span style=color:#a6e22e>User</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#a6e22e>usersBucketName</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>userBytes</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Get</span>([]byte(<span style=color:#a6e22e>email</span>))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>userBytes</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>CheckPassword</span>(<span style=color:#a6e22e>password</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;ERROR: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Invalid Login Attempt for User: %s&#34;</span>, <span style=color:#a6e22e>email</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;Invalid Email/Password Combnation&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>token</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>TS</span>.<span style=color:#a6e22e>CreateToken</span>(<span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>token</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Great Success! We&rsquo;ve all learned something here (hopefully). I&rsquo;ve learned how to make something actually useful with Go. You&rsquo;ve hopefully learned it as well. We&rsquo;ve put together a service that is built using go, with an embedded database, and has just one small job to perform. It&rsquo;s got some tests so you can update code and feel more confident about it, and you could call it from other apps on your network.</p><p>There&rsquo;s a bunch of security things you should do before using this in a production environment such as:</p><ul><li>Limiting hosts and ports that can make requests to the server (CORS)</li><li>Setting up SSL certificates to host</li><li>Disabling non-SSL/TLS connections</li><li>Automatic backups of your database file</li><li>Refactoring your secrets into a config file or to CLI variables</li><li>Implementing functionality to revoke token access for a specific user</li><li>Add in some permissions to the user to have some granularity for controls within your suite of apps</li></ul><p>Hopefully these posts have been as insightful for you to read as me to write! I&rsquo;ll have the code up on my github in the near future.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jimdhughes.com/tags/golang/>Golang</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jimdhughes.com/>James Hughes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>