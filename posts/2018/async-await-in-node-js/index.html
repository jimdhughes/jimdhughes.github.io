<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Async / Await in Node.js | James Hughes</title>
<meta name=keywords content="nodejs,async/await,asynchronous"><meta name=description content="The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend.  The Async / Await paradigm works with promises to do exactly what the paradigm implies.  It will asynchronously call the function and await it&rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4."><meta name=author content="James D Hughes"><link rel=canonical href=https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.jimdhughes.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.jimdhughes.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.jimdhughes.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.jimdhughes.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.jimdhughes.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/"><meta property="og:site_name" content="James Hughes"><meta property="og:title" content="Async / Await in Node.js"><meta property="og:description" content="The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend. The Async / Await paradigm works with promises to do exactly what the paradigm implies. It will asynchronously call the function and await it’s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-05-31T01:35:29+00:00"><meta property="article:modified_time" content="2018-05-31T01:35:29+00:00"><meta property="article:tag" content="Nodejs"><meta property="article:tag" content="Async/Await"><meta property="article:tag" content="Asynchronous"><meta name=twitter:card content="summary"><meta name=twitter:title content="Async / Await in Node.js"><meta name=twitter:description content="The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend.  The Async / Await paradigm works with promises to do exactly what the paradigm implies.  It will asynchronously call the function and await it&rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Async / Await in Node.js","item":"https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Async / Await in Node.js","name":"Async \/ Await in Node.js","description":"The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend. The Async / Await paradigm works with promises to do exactly what the paradigm implies. It will asynchronously call the function and await it\u0026rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4.\n","keywords":["nodejs","async/await","asynchronous"],"articleBody":"The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend. The Async / Await paradigm works with promises to do exactly what the paradigm implies. It will asynchronously call the function and await it’s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4.\nHere’s an example of a relatively easy to read chain of promises that I use in a production application to generate a user’s timesheet.\nfunction getTimesheet(user, date, offset) { return new Promise((resolve, reject) =\u003e { getCompanyConfig(user) .then((result) =\u003e { return getTimesheetObject(result.config, result.user, date, offset); }) .then((timesheetObject) =\u003e { return executeTimesheetRequest(timesheetObject); }) .then((timesheetBuffer) =\u003e { resolve(timesheetBuffer); }) .catch((e) =\u003e { console.error(e); reject(e); }); }); } Imagine this with callback hell. I thought promises were delightful until async / await was introduced.Essentially this function takes in a user, the date they’re requesting a timesheet for, and the timezone_offset (calculated from the request object as we’re located in multiple timezones). The function returns a promise of a binary buffer of the excel-based timesheet report required for legacy systems and for sign off by managers and clients.\nNow to refactor this as a beautiful async / await function!\nasync function getTimesheet(user, date, offset) { try { let config = await getCompanyConfig(user); let timesheetObject = await getTimesheetObject(config.config, config.user, date, offset); let buffer = await executeTimesheetRequest(timesheetObject); return buffer; } catch (e) { console.error(e); throw e; } } There we have it. The code is way more readable and flexible. If i needed to pass that configuration object into by executeTimesheetRequest() function then I could just do it instead of having to find inventive ways of chaining the config through the getTimesheetObject() function. I’ve even left this open enough to refactor the getcompanyConfig() function into two separate functions (as I originally intended) but had problems with returning the results of two promises to the getTimesheetObject() function.\nIn the first bit of code it is obvious that we need to do some extra work to get both the user and config object to chain into the next function.\nHere is an example of my getCompanyConfig function that I’m going to also convert to async/await:\nfunction getCompanyConfig(userId) { return new Promise((resolve, reject) =\u003e { User.findById(userId, { include: [models.Company] }) .then((u) =\u003e { if (!exportConfiguration.templates[u.Company.name]) { console.error('No Configuration Avaialable for Company: ' + u.Company.name); reject(new Error('No Configuration available for company: ' + u.Company.name)); } else { resolve({ user: u, config: exportConfiguration.config }); } }) .catch((e) =\u003e { console.error('Error Finding User'); reject(e); }) }); } It’s pretty verbose and a touch confusing.\nasync function getCompanyConfig(userId) { try { let user = await User.findById(userId, {include:[models.Company]}); if (!exportConfiguration.templates[user.Company.name]) { throw new Error('No Template Available for Company: '+u.Company.name); } return { user: user, config: exportConfiguration.config } } catch (e){ throw e; } } Smaller. Tighter. Cleaner. I can now also break this into two smaller functions that return more meaningful things. 1 - The getUser function and the getCompanyConfig function which will return ONLY the user information and the company information as required.\nFirst we’ll take the user definition out of the getCompanyConfig controller and put it in the getTimesheet function. Then we will adjust our getCompanyConfig function to only handle validating and returning the configuration object.\nasync function getTimesheet(userId, date, offset) { try { let user = await User.findById(userId, { include: [models.Company] }); let config = await getCompanyConfig(user.Company.name); let timesheetObject = await getTimesheetObject(config, user, date, offset); let buffer = await executeTimesheetRequest(timesheetObject); return buffer; } catch (e) { console.error('Error Retreiving Timesheet', e); throw e; } } async function getCompanyConfig(companyName) { try { if (!exportConfiguration.templates[companyName]) { throw new Error('No Template Available for Company: ' + u.Company.name); } return exportConfiguration.config; } catch (e) { throw e; } } There we have it.\nThe Async / Await functionality has made this small portion of code WAY more readable and way more maintainable. I can now have functions handle specific actions and I can successfully handle the behaviour in a way that feels more synchronous but while not blocking the event loop.\nHopefully this has inspired you to give it a go!\n","wordCount":"731","inLanguage":"en","datePublished":"2018-05-31T01:35:29Z","dateModified":"2018-05-31T01:35:29Z","author":{"@type":"Person","name":"James D Hughes"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/"},"publisher":{"@type":"Organization","name":"James Hughes","logo":{"@type":"ImageObject","url":"https://blog.jimdhughes.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.jimdhughes.com/ accesskey=h title="James Hughes (Alt + H)">James Hughes</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Async / Await in Node.js</h1><div class=post-meta><span title='2018-05-31 01:35:29 +0000 UTC'>May 31, 2018</span>&nbsp;·&nbsp;James D Hughes</div></header><div class=post-content><p>The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend. The Async / Await paradigm works with promises to do exactly what the paradigm implies. It will asynchronously call the function and await it&rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4.</p><p>Here&rsquo;s an example of a relatively easy to read chain of promises that I use in a production application to generate a user&rsquo;s timesheet.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getTimesheet</span>(<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>user</span>)
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>result</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getTimesheetObject</span>(<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>config</span>, <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>);
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>timesheetObject</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>executeTimesheetRequest</span>(<span style=color:#a6e22e>timesheetObject</span>);
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>timesheetBuffer</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>resolve</span>(<span style=color:#a6e22e>timesheetBuffer</span>);
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>e</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>e</span>);
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Imagine this with callback hell. I thought promises were delightful until async / await was introduced.Essentially this function takes in a user, the date they&rsquo;re requesting a timesheet for, and the timezone_offset (calculated from the request object as we&rsquo;re located in multiple timezones). The function returns a promise of a binary buffer of the excel-based timesheet report required for legacy systems and for sign off by managers and clients.</p><p>Now to refactor this as a beautiful async / await function!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getTimesheet</span>(<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>user</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timesheetObject</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getTimesheetObject</span>(<span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>config</span>, <span style=color:#a6e22e>config</span>.<span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>executeTimesheetRequest</span>(<span style=color:#a6e22e>timesheetObject</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buffer</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#a6e22e>e</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>e</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There we have it. The code is way more readable and flexible. If i needed to pass that configuration object into by executeTimesheetRequest() function then I could just do it instead of having to find inventive ways of chaining the config through the getTimesheetObject() function. I&rsquo;ve even left this open enough to refactor the getcompanyConfig() function into two separate functions (as I originally intended) but had problems with returning the results of two promises to the getTimesheetObject() function.</p><p>In the first bit of code it is obvious that we need to do some extra work to get both the user and config object to chain into the next function.</p><p>Here is an example of my getCompanyConfig function that I&rsquo;m going to also convert to async/await:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>userId</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>new</span> Promise((<span style=color:#a6e22e>resolve</span>, <span style=color:#a6e22e>reject</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>findById</span>(<span style=color:#a6e22e>userId</span>, {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>include</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Company</span>]
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>((<span style=color:#a6e22e>u</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>templates</span>[<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>]) {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;No Configuration Avaialable for Company: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>reject</span>(<span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;No Configuration available for company: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>resolve</span>({
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>u</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>config</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>config</span>
</span></span><span style=display:flex><span>          });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>((<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Error Finding User&#39;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>reject</span>(<span style=color:#a6e22e>e</span>);
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s pretty verbose and a touch confusing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>userId</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>findById</span>(<span style=color:#a6e22e>userId</span>, {<span style=color:#a6e22e>include</span><span style=color:#f92672>:</span>[<span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Company</span>]});
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>templates</span>[<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>]) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;No Template Available for Company: &#39;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>user</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>user</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>config</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>config</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>e</span>;
</span></span><span style=display:flex><span>  } 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Smaller. Tighter. Cleaner. I can now also break this into two smaller functions that return more meaningful things. 1 - The getUser function and the getCompanyConfig function which will return ONLY the user information and the company information as required.</p><p>First we&rsquo;ll take the user definition out of the getCompanyConfig controller and put it in the getTimesheet function. Then we will adjust our getCompanyConfig function to only handle validating and returning the configuration object.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getTimesheet</span>(<span style=color:#a6e22e>userId</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>user</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>User</span>.<span style=color:#a6e22e>findById</span>(<span style=color:#a6e22e>userId</span>, { <span style=color:#a6e22e>include</span><span style=color:#f92672>:</span> [<span style=color:#a6e22e>models</span>.<span style=color:#a6e22e>Company</span>] });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>user</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>timesheetObject</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>getTimesheetObject</span>(<span style=color:#a6e22e>config</span>, <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>date</span>, <span style=color:#a6e22e>offset</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>buffer</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>executeTimesheetRequest</span>(<span style=color:#a6e22e>timesheetObject</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>buffer</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>error</span>(<span style=color:#e6db74>&#39;Error Retreiving Timesheet&#39;</span>, <span style=color:#a6e22e>e</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>e</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>getCompanyConfig</span>(<span style=color:#a6e22e>companyName</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>templates</span>[<span style=color:#a6e22e>companyName</span>]) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> Error(<span style=color:#e6db74>&#39;No Template Available for Company: &#39;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>Company</span>.<span style=color:#a6e22e>name</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>exportConfiguration</span>.<span style=color:#a6e22e>config</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>catch</span> (<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>e</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>There we have it.</p><p>The Async / Await functionality has made this small portion of code WAY more readable and way more maintainable. I can now have functions handle specific actions and I can successfully handle the behaviour in a way that feels more synchronous but while not blocking the event loop.</p><p>Hopefully this has inspired you to give it a go!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.jimdhughes.com/tags/nodejs/>Nodejs</a></li><li><a href=https://blog.jimdhughes.com/tags/async/await/>Async/Await</a></li><li><a href=https://blog.jimdhughes.com/tags/asynchronous/>Asynchronous</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://blog.jimdhughes.com/>James Hughes</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>