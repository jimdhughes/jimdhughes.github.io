<!doctype html><html lang=en><meta charset=utf-8><meta name=generator content="Hugo 0.64.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><title>nodejs&nbsp;&ndash;&nbsp;James Hughes</title><link rel=stylesheet href=/css/core.min.99d761621eb15531f47d6f109c742c4d2f97f9c10fed380e3da27af7676a27a1fb5968bfbd3207717f11d40ad1d68b92.css integrity=sha384-mddhYh6xVTH0fW8QnHQsTS+X+cEP7TgOPaJ692dqJ6H7WWi/vTIHcX8R1ArR1ouS><link rel=alternate type=application/rss+xml href=/tags/nodejs/index.xml title="James Hughes"><meta name=twitter:card content="summary"><meta name=twitter:title content="nodejs"><body><section id=header><div class="header wrap"><span class="header left-side"><a class="site home" href=/><span class="site name">James Hughes</span></a></span>
<span class="header right-side"><div class="nav wrap"><nav class=nav><a class="nav item" href=/categories/>Categories</a><a class="nav item" href=/tags/>Tags</a><a class="nav item" href></a><a class="nav item" href></a></nav></div></span></div></section><section id=content><section class="article header"><h1>nodejs</h1></section><ul class="note list"><li class=item><a class=note href=/posts/2019/benchmarking-a-pi-calculation-for-fun/><p class="note title">Benchmarking a pi calculation for fun</p><p class="note date">Wednesday, May 22, 2019</p><p class="note content">Dotnet Core, Golang, Node, C, Java, Python.
This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js. As is typical when things like these arise, our team&rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - &ldquo;Do you think cypress would be faster than selenium?<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/nodejs/>nodejs</a><a class=category href=/categories/golang/>golang</a><a class=category href=/categories/java/>java</a><a class=category href=/categories/python/>python</a><a class=category href=/categories/c/>c</a><a class=category href=/categories/programming/>programming</a><a class=category href=/categories/pi/>pi</a><a class=category href=/categories/algorithms/>algorithms</a><a class=tag href=/tags/nodejs/>nodejs</a><a class=tag href=/tags/golang/>golang</a><a class=tag href=/tags/java/>java</a><a class=tag href=/tags/python/>python</a><a class=tag href=/tags/c/>c</a><a class=tag href=/tags/programming/>programming</a><a class=tag href=/tags/pi/>pi</a><a class=tag href=/tags/algorithms/>algorithms</a></p></li><li class=item><a class=note href=/posts/2018/fetching-data-with-react/><p class="note title">Fetching data with react</p><p class="note date">Wednesday, August 29, 2018</p><p class="note content">What use is an app that can&rsquo;t persist data?
I&rsquo;m continuing this from my previous post about my efforts to learn about react. I want to be able to persist my data on a server and display it on a web client. To my understanding, this should be pretty simple so I&rsquo;m going to put that theory to the test.
Firstly! We&rsquo;re going to use a Node.js scaffold that I covered off in a previous posting as our backend for this app.<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/reactjs/>ReactJS</a><a class=category href=/categories/nodejs/>nodejs</a><a class=tag href=/tags/reactjs/>ReactJS</a><a class=tag href=/tags/nodejs/>nodejs</a></p></li><li class=item><a class=note href=/posts/2018/async-await-in-node-js/><p class="note title">Async / Await in Node.js</p><p class="note date">Thursday, May 31, 2018</p><p class="note content">The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend. The Async / Await paradigm works with promises to do exactly what the paradigm implies. It will asynchronously call the function and await it&rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4.<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/nodejs/>nodejs</a><a class=category href=/categories/async/await/>async/await</a><a class=category href=/categories/asynchronous/>asynchronous</a><a class=tag href=/tags/nodejs/>nodejs</a><a class=tag href=/tags/async/await/>async/await</a><a class=tag href=/tags/asynchronous/>asynchronous</a></p></li><li class=item><a class=note href=/posts/2018/yet-another-stateless-authentication-blog-post-for-the-mean-stack/><p class="note title">Yet Another Stateless Authentication Blog Post for the MEAN stack.</p><p class="note date">Saturday, May 5, 2018</p><p class="note content">#inb4: this ain&rsquo;t new.
I&rsquo;m writing this for everyone that wants a slightly more organized approach to express middleware and authentication. I&rsquo;m writing this because once again I was inspired by how much I adore Node, Express, and all the delights that come from being able to implement my API&rsquo;s and leverage middlewares. Also, I&rsquo;m using async / await, which is pretty neat.
I&rsquo;m going to use MongoDB as a datastore it just jives so well with Node.<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/nodejs/>nodejs</a><a class=category href=/categories/rest/>REST</a><a class=category href=/categories/jwt/>JWT</a><a class=category href=/categories/expressjs/>ExpressJS</a><a class=category href=/categories/middleware/>Middleware</a><a class=category href=/categories/development/>development</a><a class=category href=/categories/javascript/>JavaScript</a><a class=category href=/categories/mongodb/>MongoDB</a><a class=category href=/categories/async/>async</a><a class=tag href=/tags/nodejs/>nodejs</a><a class=tag href=/tags/rest/>REST</a><a class=tag href=/tags/jwt/>JWT</a><a class=tag href=/tags/expressjs/>ExpressJS</a><a class=tag href=/tags/middleware/>Middleware</a><a class=tag href=/tags/development/>development</a><a class=tag href=/tags/javascript/>JavaScript</a><a class=tag href=/tags/mongodb/>MongoDB</a><a class=tag href=/tags/async/>async</a></p></li><li class=item><a class=note href=/posts/2015/installing-node-without-sudo/><p class="note title">Installing Node without Sudo - Ubuntu 14.04 LTS</p><p class="note date">Wednesday, April 8, 2015</p><p class="note content">If you&rsquo;re unlike me and really don&rsquo;t care about superuser permissions or having the most up-to-date releases, you can just do the regular old naive thing and use the package manager&mldr;
sudo apt-get update && sudo apt-get install nodejs However since you&rsquo;re here, I&rsquo;m betting this doesn&rsquo;t jive with you.
The idea of having to give checked out source code from the npm repository super user access makes me quite uncomfortable.<span class=mldr>&mldr;</span></p></a><p class="note labels"><a class=category href=/categories/nodejs/>nodejs</a><a class=category href=/categories/tutorial/>tutorial</a><a class=category href=/categories/ubuntu/>ubuntu</a><a class=category href=/categories/npm/>npm</a><a class=tag href=/tags/nodejs/>nodejs</a><a class=tag href=/tags/tutorial/>tutorial</a><a class=tag href=/tags/ubuntu/>ubuntu</a><a class=tag href=/tags/npm/>npm</a></p></li></ul></section><section id=footer><div class=footer-wrap><p class=copyright>Â©2020 James Hughes.</p><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank>Hugo</a><span> and the </span><a href=https://themes.gohugo.io/hugo-notepadium/ target=_blank>Notepadium</a></p></div></section></body></html>