<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Nodejs on James Hughes</title>
    <link>https://blog.jimdhughes.com/tags/nodejs/</link>
    <description>Recent content in Nodejs on James Hughes</description>
    <generator>Hugo -- 0.142.0</generator>
    <language>en</language>
    <lastBuildDate>Wed, 22 May 2019 09:51:39 +0000</lastBuildDate>
    <atom:link href="https://blog.jimdhughes.com/tags/nodejs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Benchmarking a pi calculation for fun</title>
      <link>https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/</link>
      <pubDate>Wed, 22 May 2019 09:51:39 +0000</pubDate>
      <guid>https://blog.jimdhughes.com/posts/2019/benchmarking-a-pi-calculation-for-fun/</guid>
      <description>&lt;p&gt;Dotnet Core, Golang, Node, C, Java, Python.&lt;/p&gt;
&lt;p&gt;This is what I felt like doing on a Tuesday night after seeing yet another article discussing the performance of dotnet core over node.js.  As is typical when things like these arise, our team&amp;rsquo;s slack channel went into the lightest of debates about C# vs Node, compiled speeds vs interpreted languages, and finally back to what we were originally discussing - &amp;ldquo;Do you think cypress would be faster than selenium?&amp;rdquo;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Fetching data with react</title>
      <link>https://blog.jimdhughes.com/posts/2018/fetching-data-with-react/</link>
      <pubDate>Wed, 29 Aug 2018 02:37:01 +0000</pubDate>
      <guid>https://blog.jimdhughes.com/posts/2018/fetching-data-with-react/</guid>
      <description>&lt;p&gt;What use is an app that can&amp;rsquo;t persist data?&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m continuing this from my previous post about my efforts to learn about react.  I want to be able to persist my data on a server and display it on a web client.  To my understanding, this should be pretty simple so I&amp;rsquo;m going to put that theory to the test.&lt;/p&gt;
&lt;h1 id=&#34;firstly&#34;&gt;Firstly!&lt;/h1&gt;
&lt;p&gt;We&amp;rsquo;re going to use a Node.js scaffold that I covered off in a previous posting as our backend for this app. It&amp;rsquo;s located &lt;a href=&#34;https://github.com/jimdhughes/jdhc-express-stateless-template&#34;&gt;here&lt;/a&gt; and requires you to have Node.js installed and access to a MongoDB Instance.  Follow the instructions in that repo to get up and running.  If you don&amp;rsquo;t want to use that one, you can set up your own REST service (or CouchDB instance?) and follow along with the concepts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Async / Await in Node.js</title>
      <link>https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/</link>
      <pubDate>Thu, 31 May 2018 01:35:29 +0000</pubDate>
      <guid>https://blog.jimdhughes.com/posts/2018/async-await-in-node-js/</guid>
      <description>&lt;p&gt;The Async / Await functionality introduced into Node.js in v7.10.0 is legitimately a godsend.  The Async / Await paradigm works with promises to do exactly what the paradigm implies.  It will asynchronously call the function and await it&amp;rsquo;s response before continuing on with the rest of the function. Previously, you could do this with promise chaining. Passing results from one promise to the next. Where this issue fell apart is when you needed to use the result of Promise 1 in Promise 4. You would need to somehow pass the result of Promise 1 through Promises 2 and 3 in order to use them in promise 4.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Yet Another Stateless Authentication Blog Post for the MEAN stack.</title>
      <link>https://blog.jimdhughes.com/posts/2018/yet-another-stateless-authentication-blog-post-for-the-mean-stack/</link>
      <pubDate>Sat, 05 May 2018 03:32:35 +0000</pubDate>
      <guid>https://blog.jimdhughes.com/posts/2018/yet-another-stateless-authentication-blog-post-for-the-mean-stack/</guid>
      <description>&lt;p&gt;#inb4: this ain&amp;rsquo;t new.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m writing this for everyone that wants a &lt;em&gt;slightly&lt;/em&gt; more organized approach to express middleware and authentication.  I&amp;rsquo;m writing this because once again I was inspired by how much I &lt;strong&gt;adore&lt;/strong&gt; Node, Express, and all the delights that come from being able to implement my API&amp;rsquo;s and leverage middlewares.  Also, I&amp;rsquo;m using async / await, which is pretty neat.&lt;/p&gt;
&lt;p&gt;I&amp;rsquo;m going to use MongoDB as a datastore it just jives so well with Node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Installing Node without Sudo - Ubuntu 14.04 LTS</title>
      <link>https://blog.jimdhughes.com/posts/2015/installing-node-without-sudo/</link>
      <pubDate>Wed, 08 Apr 2015 03:42:01 +0000</pubDate>
      <guid>https://blog.jimdhughes.com/posts/2015/installing-node-without-sudo/</guid>
      <description>&lt;p&gt;If you&amp;rsquo;re unlike me and really don&amp;rsquo;t care about superuser permissions or having the most up-to-date releases, you can just do the regular old naive thing and use the package manager&amp;hellip;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get install nodejs
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However since you&amp;rsquo;re here, I&amp;rsquo;m betting this doesn&amp;rsquo;t jive with you.&lt;/p&gt;
&lt;p&gt;The idea of having to give checked out source code from the npm repository super user access makes me quite uncomfortable. I mean, all it&amp;rsquo;s going to do is sit on a virtual machine that will remain dormant long after I complete an awesome a-snychronous ToDo application and feel like a boss. It&amp;rsquo;s the principal of the matter!&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
